use serde::Serialize;
use std::collections::{BTreeMap, BTreeSet};
use std::fs;
use std::io;
use std::path::{Path, PathBuf};

#[derive(Debug, Serialize)]
pub struct ApplyResponse {
    pub ok: bool,
    pub message: Option<String>,
    pub restart_hint: Option<String>,
}

#[derive(Debug)]
pub struct ParsedEnv {
    pub vars: BTreeMap<String, String>,
    pub keys: BTreeSet<String>,
}

fn is_valid_key(key: &str) -> bool {
    let mut chars = key.chars();
    let Some(first) = chars.next() else { return false };
    if !(first.is_ascii_alphabetic() || first == '_') {
        return false;
    }
    chars.all(|c| c.is_ascii_alphanumeric() || c == '_')
}

pub fn parse_dotenv_like(content: &str) -> Result<ParsedEnv, String> {
    let mut vars = BTreeMap::<String, String>::new();
    for (idx, raw_line) in content.lines().enumerate() {
        let line_no = idx + 1;
        let line = raw_line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }
        let Some((k, v)) = line.split_once('=') else {
            return Err(format!("line {line_no}: expected KEY=VALUE"));
        };
        let key = k.trim();
        if !is_valid_key(key) {
            return Err(format!("line {line_no}: invalid key '{key}'"));
        }
        let value = v.trim().to_string();
        vars.insert(key.to_string(), value);
    }
    let keys = vars.keys().cloned().collect::<BTreeSet<_>>();
    Ok(ParsedEnv { vars, keys })
}

#[cfg(windows)]
pub fn config_dir_from_base(config_base: &Path) -> PathBuf {
    config_base.join("ev")
}

#[cfg(not(windows))]
pub fn config_dir_from_home(home_dir: &Path) -> PathBuf {
    home_dir.join(".config").join("ev")
}

fn read_managed_keys(dir: &Path) -> BTreeSet<String> {
    let path = dir.join("managed.keys");
    let Ok(data) = fs::read_to_string(path) else { return BTreeSet::new() };
    data.lines()
        .map(|l| l.trim())
        .filter(|l| !l.is_empty())
        .map(|l| l.to_string())
        .collect()
}

fn write_managed_keys(dir: &Path, keys: &BTreeSet<String>) -> io::Result<()> {
    let path = dir.join("managed.keys");
    let mut out = String::new();
    for k in keys {
        out.push_str(k);
        out.push('\n');
    }
    fs::write(path, out)
}

fn escape_single_quotes(s: &str) -> String {
    // POSIX-ish single quote escaping: close, escape, reopen.
    // ' -> '"'"'
    s.replace('\'', r#"'"'"'"#)
}

fn write_shell_scripts(dir: &Path, managed_keys: &BTreeSet<String>, vars: &BTreeMap<String, String>) -> io::Result<()> {
    // sh/zsh
    let mut sh = String::new();
    sh.push_str("# Generated by ev. Source this file in your shell.\n");
    sh.push_str("# Example (Linux/macOS): source ~/.config/ev/ev.sh\n");
    sh.push_str("# The actual location may differ; see Tauri Config directory.\n\n");
    for k in managed_keys {
        sh.push_str("unset ");
        sh.push_str(k);
        sh.push('\n');
    }
    for (k, v) in vars {
        sh.push_str("export ");
        sh.push_str(k);
        sh.push_str("='");
        sh.push_str(&escape_single_quotes(v));
        sh.push_str("'\n");
    }
    fs::write(dir.join("ev.sh"), &sh)?;
    fs::write(dir.join("ev.zsh"), &sh)?;

    // fish
    let mut fish = String::new();
    fish.push_str("# Generated by ev. Source this file in fish.\n");
    fish.push_str("# Example: source ~/.config/ev/ev.fish\n\n");
    for k in managed_keys {
        fish.push_str("set -e ");
        fish.push_str(k);
        fish.push('\n');
    }
    for (k, v) in vars {
        fish.push_str("set -gx ");
        fish.push_str(k);
        fish.push_str(" '");
        fish.push_str(&escape_single_quotes(v));
        fish.push_str("'\n");
    }
    fs::write(dir.join("ev.fish"), fish)?;

    // helpful debug file
    let mut env_txt = String::new();
    for (k, v) in vars {
        env_txt.push_str(k);
        env_txt.push('=');
        env_txt.push_str(v);
        env_txt.push('\n');
    }
    fs::write(dir.join("active.env"), env_txt)?;

    Ok(())
}

#[cfg(not(windows))]
pub fn apply_platform(dir: &Path, parsed: &ParsedEnv) -> Result<ApplyResponse, String> {
    fs::create_dir_all(dir).map_err(|e| e.to_string())?;
    let old = read_managed_keys(dir);
    let mut managed = old;
    managed.extend(parsed.keys.iter().cloned());
    write_shell_scripts(dir, &managed, &parsed.vars).map_err(|e| e.to_string())?;
    write_managed_keys(dir, &managed).map_err(|e| e.to_string())?;
    Ok(ApplyResponse {
        ok: true,
        message: Some("Applied via shell integration files.".to_string()),
        restart_hint: Some("Reload your shell (source the ev script) or open a new terminal.".to_string()),
    })
}

#[cfg(not(windows))]
pub fn disable_platform(dir: &Path) -> Result<ApplyResponse, String> {
    fs::create_dir_all(dir).map_err(|e| e.to_string())?;
    let managed = read_managed_keys(dir);
    let vars = BTreeMap::<String, String>::new();
    write_shell_scripts(dir, &managed, &vars).map_err(|e| e.to_string())?;
    Ok(ApplyResponse {
        ok: true,
        message: Some("Disabled via shell integration files.".to_string()),
        restart_hint: Some("Reload your shell (source the ev script) or open a new terminal.".to_string()),
    })
}

#[cfg(windows)]
mod win {
    use super::*;
    use winreg::enums::HKEY_CURRENT_USER;
    use winreg::RegKey;

    use windows_sys::Win32::Foundation::{HWND, LPARAM, WPARAM};
    use windows_sys::Win32::UI::WindowsAndMessaging::{
        SendMessageTimeoutW, HWND_BROADCAST, SMTO_ABORTIFHUNG, WM_SETTINGCHANGE,
    };

    fn broadcast_env_change() {
        let wide: Vec<u16> = "Environment\0".encode_utf16().collect();
        unsafe {
            SendMessageTimeoutW(
                HWND_BROADCAST as HWND,
                WM_SETTINGCHANGE,
                0 as WPARAM,
                wide.as_ptr() as LPARAM,
                SMTO_ABORTIFHUNG,
                2000,
                std::ptr::null_mut(),
            );
        }
    }

    pub fn apply_windows(dir: &Path, parsed: &ParsedEnv) -> Result<ApplyResponse, String> {
        fs::create_dir_all(dir).map_err(|e| e.to_string())?;
        let old = read_managed_keys(dir);
        let mut managed = old;
        managed.extend(parsed.keys.iter().cloned());

        let hkcu = RegKey::predef(HKEY_CURRENT_USER);
        let env = hkcu
            .open_subkey_with_flags("Environment", winreg::enums::KEY_SET_VALUE)
            .map_err(|e| e.to_string())?;

        // Clear managed keys first, then set the new ones.
        for k in &managed {
            let _ = env.delete_value(k);
        }
        for (k, v) in &parsed.vars {
            env.set_value(k, &v.as_str()).map_err(|e| e.to_string())?;
        }

        write_managed_keys(dir, &managed).map_err(|e| e.to_string())?;
        broadcast_env_change();

        Ok(ApplyResponse {
            ok: true,
            message: Some("Applied to user environment variables (HKCU).".to_string()),
            restart_hint: Some("Open a new terminal/app to pick up updated environment variables.".to_string()),
        })
    }

    pub fn disable_windows(dir: &Path) -> Result<ApplyResponse, String> {
        fs::create_dir_all(dir).map_err(|e| e.to_string())?;
        let managed = read_managed_keys(dir);

        let hkcu = RegKey::predef(HKEY_CURRENT_USER);
        let env = hkcu
            .open_subkey_with_flags("Environment", winreg::enums::KEY_SET_VALUE)
            .map_err(|e| e.to_string())?;

        for k in &managed {
            let _ = env.delete_value(k);
        }
        broadcast_env_change();

        Ok(ApplyResponse {
            ok: true,
            message: Some("Disabled from user environment variables (HKCU).".to_string()),
            restart_hint: Some("Open a new terminal/app to pick up updated environment variables.".to_string()),
        })
    }
}

#[cfg(windows)]
pub fn apply_platform(dir: &Path, parsed: &ParsedEnv) -> Result<ApplyResponse, String> {
    win::apply_windows(dir, parsed)
}

#[cfg(windows)]
pub fn disable_platform(dir: &Path) -> Result<ApplyResponse, String> {
    win::disable_windows(dir)
}


